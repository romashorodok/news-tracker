// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: articles.sql

package storage

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const articles = `-- name: Articles :many
WITH ImageData AS (
    SELECT DISTINCT ON (ai.image_id)
        ai.image_id,
        ai.main,
        i.url,
        ai.article_id
    FROM article_images ai
    JOIN images i ON ai.image_id = i.id
)
SELECT
    articles.id, articles.title, articles.preface, articles.content, articles.origin, articles.viewers_count, articles.created_at, articles.updated_at, articles.published_at,
    array_to_json(array_agg(row_to_json(images))) AS images
FROM articles
LEFT JOIN ImageData AS images ON articles.id = images.article_id
WHERE
    articles.published_at BETWEEN
        COALESCE($1, $2)::timestamp
        AND COALESCE($3, NOW())::timestamp
    AND (
        CAST(ARRAY_TO_JSON($4::text[]) AS VARCHAR) IN ('[null]', '[""]')
        OR to_tsvector(articles.title || ' ' || articles.content || ' ' || articles.preface)
            @@ to_tsquery(ARRAY_TO_STRING($4, ' & '))
    )
GROUP BY articles.id
ORDER BY
    CASE WHEN $5::text = 'newest' THEN articles.published_at END DESC,
    CASE WHEN $5::text = 'oldest' THEN articles.published_at END ASC
LIMIT $7::bigint
OFFSET $6::bigint
`

type ArticlesParams struct {
	StartDate        sql.NullTime
	StartDateDefault time.Time
	EndDate          sql.NullTime
	Lexems           []string
	ArticleSorting   string
	Page             int64
	PageSize         int64
}

type ArticlesRow struct {
	ID           int64
	Title        string
	Preface      string
	Content      string
	Origin       string
	ViewersCount int32
	CreatedAt    time.Time
	UpdatedAt    time.Time
	PublishedAt  time.Time
	Images       json.RawMessage
}

func (q *Queries) Articles(ctx context.Context, arg ArticlesParams) ([]ArticlesRow, error) {
	rows, err := q.query(ctx, q.articlesStmt, articles,
		arg.StartDate,
		arg.StartDateDefault,
		arg.EndDate,
		pq.Array(arg.Lexems),
		arg.ArticleSorting,
		arg.Page,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ArticlesRow
	for rows.Next() {
		var i ArticlesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Preface,
			&i.Content,
			&i.Origin,
			&i.ViewersCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
			&i.Images,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const attachArticleImage = `-- name: AttachArticleImage :exec
INSERT INTO article_images (
    article_id, image_id, main
) VALUES (
    $1, $2, $3
)
`

type AttachArticleImageParams struct {
	ArticleID int64
	ImageID   int64
	Main      bool
}

func (q *Queries) AttachArticleImage(ctx context.Context, arg AttachArticleImageParams) error {
	_, err := q.exec(ctx, q.attachArticleImageStmt, attachArticleImage, arg.ArticleID, arg.ImageID, arg.Main)
	return err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT id, title, preface, content, origin, viewers_count, created_at, updated_at, published_at, (
    SELECT
        array_to_json(array_agg(row_to_json(images))) AS json_array
    FROM (
        SELECT images.url, article_images.main
        FROM images
        JOIN (
            SELECT DISTINCT main, image_id
            FROM article_images
            WHERE article_id = $1
        ) AS article_images
        ON images.id = article_images.image_id
    ) as images
) as images
FROM articles
WHERE articles.id = $1
`

type GetArticleByIDRow struct {
	ID           int64
	Title        string
	Preface      string
	Content      string
	Origin       string
	ViewersCount int32
	CreatedAt    time.Time
	UpdatedAt    time.Time
	PublishedAt  time.Time
	Images       json.RawMessage
}

func (q *Queries) GetArticleByID(ctx context.Context, id int64) (GetArticleByIDRow, error) {
	row := q.queryRow(ctx, q.getArticleByIDStmt, getArticleByID, id)
	var i GetArticleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Preface,
		&i.Content,
		&i.Origin,
		&i.ViewersCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.Images,
	)
	return i, err
}

const getArticleCount = `-- name: GetArticleCount :one
SELECT COUNT(*)
FROM articles
WHERE
    articles.published_at BETWEEN
        COALESCE($1, $2)::timestamp
        AND COALESCE($3, NOW())::timestamp
AND
(
    CAST(ARRAY_TO_JSON($4::text[]) AS VARCHAR) IN ('[null]', '[""]')  OR
    to_tsvector(articles.title || ' ' || articles.content || ' ' || articles.preface)
    @@ to_tsquery(ARRAY_TO_STRING($4, ' & '))
)
`

type GetArticleCountParams struct {
	StartDate        sql.NullTime
	StartDateDefault time.Time
	EndDate          sql.NullTime
	Lexems           []string
}

func (q *Queries) GetArticleCount(ctx context.Context, arg GetArticleCountParams) (int64, error) {
	row := q.queryRow(ctx, q.getArticleCountStmt, getArticleCount,
		arg.StartDate,
		arg.StartDateDefault,
		arg.EndDate,
		pq.Array(arg.Lexems),
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getArticleIDByTitleAndOrigin = `-- name: GetArticleIDByTitleAndOrigin :one
SELECT id FROM articles
WHERE ($1::text = '' OR title ILIKE '%' || $1 || '%')
AND origin = $2
`

type GetArticleIDByTitleAndOriginParams struct {
	Title  string
	Origin string
}

func (q *Queries) GetArticleIDByTitleAndOrigin(ctx context.Context, arg GetArticleIDByTitleAndOriginParams) (int64, error) {
	row := q.queryRow(ctx, q.getArticleIDByTitleAndOriginStmt, getArticleIDByTitleAndOrigin, arg.Title, arg.Origin)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const newArticle = `-- name: NewArticle :one

INSERT INTO articles (
    title, preface, content,
    origin, viewers_count, published_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6
) RETURNING id
`

type NewArticleParams struct {
	Title        string
	Preface      string
	Content      string
	Origin       string
	ViewersCount int32
	PublishedAt  time.Time
}

// https://docs.sqlc.dev/en/stable/reference/query-annotations.html
// https://github.com/sqlc-dev/sqlc/issues/1062#issuecomment-869770485
// https://docs.sqlc.dev/en/stable/howto/named_parameters.html#nullable-parameters
func (q *Queries) NewArticle(ctx context.Context, arg NewArticleParams) (int64, error) {
	row := q.queryRow(ctx, q.newArticleStmt, newArticle,
		arg.Title,
		arg.Preface,
		arg.Content,
		arg.Origin,
		arg.ViewersCount,
		arg.PublishedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const newImage = `-- name: NewImage :one
INSERT INTO images (
    url
) VALUES (
    $1
) RETURNING id
`

func (q *Queries) NewImage(ctx context.Context, url string) (int64, error) {
	row := q.queryRow(ctx, q.newImageStmt, newImage, url)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateArticleStats = `-- name: UpdateArticleStats :exec
UPDATE articles
SET
viewers_count = $1,
updated_at = $2
WHERE id = $3
`

type UpdateArticleStatsParams struct {
	ViewersCount int32
	UpdatedAt    time.Time
	ID           int64
}

func (q *Queries) UpdateArticleStats(ctx context.Context, arg UpdateArticleStatsParams) error {
	_, err := q.exec(ctx, q.updateArticleStatsStmt, updateArticleStats, arg.ViewersCount, arg.UpdatedAt, arg.ID)
	return err
}
