// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: articles.sql

package storage

import (
	"context"
	"encoding/json"
	"time"
)

const articles = `-- name: Articles :many
SELECT id, title, preface, content, origin, viewers_count, created_at, updated_at, published_at FROM articles LIMIT $2 OFFSET $1
`

type ArticlesParams struct {
	SqlOffset int32
	SqlLimit  int32
}

func (q *Queries) Articles(ctx context.Context, arg ArticlesParams) ([]Article, error) {
	rows, err := q.query(ctx, q.articlesStmt, articles, arg.SqlOffset, arg.SqlLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Preface,
			&i.Content,
			&i.Origin,
			&i.ViewersCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const attachArticleImage = `-- name: AttachArticleImage :exec
INSERT INTO article_images (
    article_id, image_id, main
) VALUES (
    $1, $2, $3
)
`

type AttachArticleImageParams struct {
	ArticleID int64
	ImageID   int64
	Main      bool
}

func (q *Queries) AttachArticleImage(ctx context.Context, arg AttachArticleImageParams) error {
	_, err := q.exec(ctx, q.attachArticleImageStmt, attachArticleImage, arg.ArticleID, arg.ImageID, arg.Main)
	return err
}

const getArticleByID = `-- name: GetArticleByID :one
SELECT id, title, preface, content, origin, viewers_count, created_at, updated_at, published_at, (
    SELECT
        array_to_json(array_agg(row_to_json(images))) AS json_array
    FROM (
        SELECT images.url, article_images.main
        FROM images
        JOIN (
            SELECT DISTINCT main, image_id
            FROM article_images
            WHERE article_id = $1
        ) AS article_images
        ON images.id = article_images.image_id
    ) as images
) as images
FROM articles
WHERE articles.id = $1
`

type GetArticleByIDRow struct {
	ID           int64
	Title        string
	Preface      string
	Content      string
	Origin       string
	ViewersCount int32
	CreatedAt    time.Time
	UpdatedAt    time.Time
	PublishedAt  time.Time
	Images       json.RawMessage
}

func (q *Queries) GetArticleByID(ctx context.Context, id int64) (GetArticleByIDRow, error) {
	row := q.queryRow(ctx, q.getArticleByIDStmt, getArticleByID, id)
	var i GetArticleByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Preface,
		&i.Content,
		&i.Origin,
		&i.ViewersCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublishedAt,
		&i.Images,
	)
	return i, err
}

const getArticleIDByTitleAndOrigin = `-- name: GetArticleIDByTitleAndOrigin :one
SELECT id FROM articles
WHERE ($1::text = '' OR title ILIKE '%' || $1 || '%')
AND origin = $2
`

type GetArticleIDByTitleAndOriginParams struct {
	Title  string
	Origin string
}

func (q *Queries) GetArticleIDByTitleAndOrigin(ctx context.Context, arg GetArticleIDByTitleAndOriginParams) (int64, error) {
	row := q.queryRow(ctx, q.getArticleIDByTitleAndOriginStmt, getArticleIDByTitleAndOrigin, arg.Title, arg.Origin)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getArticleImages = `-- name: GetArticleImages :many
SELECT images.url, article_images.main FROM images
JOIN (
    SELECT DISTINCT main, image_id FROM article_images
    WHERE article_id = $1
) AS article_images
ON images.id = article_images.image_id
`

type GetArticleImagesRow struct {
	Url  string
	Main bool
}

func (q *Queries) GetArticleImages(ctx context.Context, id int64) ([]GetArticleImagesRow, error) {
	rows, err := q.query(ctx, q.getArticleImagesStmt, getArticleImages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticleImagesRow
	for rows.Next() {
		var i GetArticleImagesRow
		if err := rows.Scan(&i.Url, &i.Main); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newArticle = `-- name: NewArticle :one

INSERT INTO articles (
    title, preface, content,
    origin, viewers_count, published_at
) VALUES (
    $1, $2, $3,
    $4, $5, $6
) RETURNING id
`

type NewArticleParams struct {
	Title        string
	Preface      string
	Content      string
	Origin       string
	ViewersCount int32
	PublishedAt  time.Time
}

// https://docs.sqlc.dev/en/stable/reference/query-annotations.html
func (q *Queries) NewArticle(ctx context.Context, arg NewArticleParams) (int64, error) {
	row := q.queryRow(ctx, q.newArticleStmt, newArticle,
		arg.Title,
		arg.Preface,
		arg.Content,
		arg.Origin,
		arg.ViewersCount,
		arg.PublishedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const newImage = `-- name: NewImage :one
INSERT INTO images (
    url
) VALUES (
    $1
) RETURNING id
`

func (q *Queries) NewImage(ctx context.Context, url string) (int64, error) {
	row := q.queryRow(ctx, q.newImageStmt, newImage, url)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateArticleStats = `-- name: UpdateArticleStats :exec
UPDATE articles
SET
viewers_count = $1,
updated_at = $2
WHERE id = $3
`

type UpdateArticleStatsParams struct {
	ViewersCount int32
	UpdatedAt    time.Time
	ID           int64
}

func (q *Queries) UpdateArticleStats(ctx context.Context, arg UpdateArticleStatsParams) error {
	_, err := q.exec(ctx, q.updateArticleStatsStmt, updateArticleStats, arg.ViewersCount, arg.UpdatedAt, arg.ID)
	return err
}
